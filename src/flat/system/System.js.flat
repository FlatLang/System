package flat/system

import flat/regex

import flat/regex/RegexStringExtensions
import flat/extensions/SyntaxStringFunctions

class {
    visible static String workingDirectory {
        get {
            native_array native var Char[] data

            external {
                #{data} = process.cwd();
            }

            return String(data)
        }
    }

    visible static String homeDirectory {
        get {
            native_array native var Char[] data

            external {
                #{data} = #{SystemGlobal.os}.homedir();
            }

            return String(data)
        }
    }

    public static async execute(String[] arguments, String workingDirectory = null, Bool: silent = false, Bool: shell = true) -> ExecutionResponse {
        let processArguments = arguments.map((arg) => {
            if (arg.findWhitespaceOutsideOfString() != -1) {
                return '"' + arg.replace("\"", "\\\"") + '"'
            }

            let doubleIndex = arg.indexOf('"')
            let singleIndex = arg.indexOf('\'')

            if (doubleIndex > 0 && (singleIndex == -1 || doubleIndex < singleIndex)) {
                return '"' + arg.replace("\"", "\\\"") + '"'
            }
            if (singleIndex > 0 && (doubleIndex == -1 || singleIndex < doubleIndex)) {
                return '\'' + arg.replace("'", "\\'") + '\''
            }

            return arg
        })

        return executeExact(processArguments, workingDirectory, silent, shell)
    }

    static async executeExact(String[] arguments, String workingDirectory = null, Bool: silent = false, Bool: shell = true) -> ExecutionResponse {
        native_array native var Char[] dataBuffer

        let stdout = Array<String>()
        let stderr = Array<String>()
        let output = Array<String>()

        var native Int exitCode

        let commandName = arguments.first
        let processArguments = arguments.skip(1)

        log.debug("Running command: #{commandName} with args: '#{processArguments}'")

        external {
            #{exitCode} = await new Promise((resolve, reject) => {
                try {
                    var childProcess = #{SystemGlobal.childProcess}.spawn(
                        #{commandName.chars.data},
                        #{processArguments.map({ _.chars.data }).data},
                        {
                            cwd: #{workingDirectory ? workingDirectory.chars.data : ".".chars.data},
                            shell: #{shell}
                        }
                    );

                    childProcess.stdout.on('data', (data) => {
                        #{dataBuffer} = data.toString();
                        #{output.add(String(dataBuffer))};
                        #{dataBuffer} = data.toString();
                        #{stdout.add(String(dataBuffer))};
                        if (#{!silent}) {
                            process.stdout.write(#{dataBuffer});
                        }
                    });

                    childProcess.stderr.on('data', (data) => {
                        #{dataBuffer} = data.toString();
                        #{output.add(String(dataBuffer))};
                        #{dataBuffer} = data.toString();
                        #{stderr.add(String(dataBuffer))};
                        if (#{!silent}) {
                            process.stderr.write(#{dataBuffer});
                        }
                    });

                    childProcess.on('error', (err) => {
                        #{dataBuffer} = err.toString();
                        reject(#{Exception(String(dataBuffer))});
                    });

                    childProcess.on('exit', (code) => {
                        resolve(code);
                    });
                } catch (e) {
                    #{dataBuffer} = e.toString();
                    reject(#{Exception(String(dataBuffer))});
                }
            });
        }

        return ExecutionResponse(
            stdout,
            stderr,
            output,
            exitCode
        )
    }

    public static async execute(String command, String workingDirectory = null, Bool: silent = false, Bool: shell = true) -> ExecutionResponse {
        let args = command.splitOnTopLevel(SyntaxStringFunctions.WHITESPACE)

        return executeExact(args, workingDirectory, silent: silent, shell: shell)
    }

    public static getEnv(String name) -> String {
        native_array native var Char[] data

        external {
            #{data} = process.env[#{name.chars.data}];

            if (typeof #{data} !== 'string') {
                return #{null};
            }
        }

        return String(data)
    }

    public static class SystemGlobal {
        external type ChildProcessType
        private static var ChildProcessType _childProcess
        visible static ChildProcessType childProcess {
            get {
                external {
                    if (!#{_childProcess}) {
                        #{_childProcess} = require('child_process');
                    }
                }

                return _childProcess
            }
        }

        external type OsType
        private static var OsType _os
        visible static OsType os {
            get {
                external {
                    if (!#{_os}) {
                        #{_os} = require('os');
                    }
                }

                return _os
            }
        }
    }
}
