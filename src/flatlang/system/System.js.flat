package "flatlang/system"

import "flatlang/extensions/SyntaxStringFunctions"

[AutoFinal]
immutable class {
    visible static String workingDirectory {
        get {
            native var Char[] data

            external {
                #{data} = process.cwd();
            }

            return new String(data)
        }
    }

    visible static String homeDirectory {
        get {
            native var Char[] data

            external {
                #{data} = #{SystemGlobal.os}.homedir();
            }

            return new String(data)
        }
    }

    public static async execute(String[] arguments, String workingDirectory = null, Bool: silent = false) -> ExecutionResponse {
        native var Char[] dataBuffer

        let stdout = new Array<String>()
        let stderr = new Array<String>()

        var native Int exitCode

        external {
            #{exitCode} = await new Promise((resolve, reject) => {
                try {
                    var childProcess = #{SystemGlobal.childProcess}.spawn(
                        #{arguments[0].chars.data},
                        #{arguments.skip(1).map({_.chars.data}).data},
                        {
                            cwd: #{workingDirectory ? workingDirectory.chars.data : ".".chars.data},
                            shell: true
                        }
                    );

                    childProcess.stdout.on('data', (data) => {
                        #{dataBuffer} = data.toString();
                        #{stdout.add(new String(dataBuffer))};
                        if (#{!silent}) {
                            process.stdout.write(#{dataBuffer});
                        }
                    });

                    childProcess.stderr.on('data', (data) => {
                        #{dataBuffer} = data.toString();
                        #{stderr.add(new String(dataBuffer))};
                        if (#{!silent}) {
                            process.stderr.write(#{dataBuffer});
                        }
                    });

                    childProcess.on('error', (err) => {
                        #{dataBuffer} = err.toString();
                        #{throw new Exception(new String(dataBuffer))};
                    });

                    childProcess.on('exit', (code) => {
                        resolve(code);
                    });
                } catch (e) {
                    #{dataBuffer} = e.toString();
                    #{throw new Exception(new String(dataBuffer))};
                }
            });
        }

        return new ExecutionResponse(
            stdout: stdout,
            stderr: stderr,
            exitCode: exitCode
        )
    }

    public static async execute(String command, String workingDirectory = null, Bool: silent = false) =>
        await execute(command.splitOnTopLevel(SyntaxStringFunctions.WHITESPACE), workingDirectory, silent: silent)

    public static getEnv(String name) -> String {
        native var Char[] data

        external {
            #{data} = process.env[#{name.chars.data}];

            if (typeof #{data} !== 'string') {
                return #{null};
            }
        }

        return new String(data)
    }

    public static class SystemGlobal {
        external type ChildProcessType
        private static var ChildProcessType _childProcess
        visible static ChildProcessType childProcess {
            get {
                external {
                    if (!#{_childProcess}) {
                        #{_childProcess} = require('child_process');
                    }
                }

                return _childProcess
            }
        }

        external type OsType
        private static var OsType _os
        visible static OsType os {
            get {
                external {
                    if (!#{_os}) {
                        #{_os} = require('os');
                    }
                }

                return _os
            }
        }
    }
}